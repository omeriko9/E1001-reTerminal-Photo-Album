/*
 * e-Paper Display Driver Implementation
 * Generic driver supporting common 800x480 e-ink panels
 */

#include "epaper_driver.h"
#include "board_config.h"
#include "font_16x24.h"

#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "esp_heap_caps.h"

static const char *TAG = "epaper";

// SPI handle
static spi_device_handle_t s_spi = NULL;
static uint8_t *s_framebuffer = NULL;
static epd_rotation_t s_rotation = EPD_ROTATE_0;
static bool s_initialized = false;

// Built-in 8x16 font (basic ASCII)
static const uint8_t font_8x16[] = {
    // Space to '~' characters
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //   (32)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x10, // ! (33)
    0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x28,0x28,0x28,0x00,0x00,0x00,0x00,0x00,0x00, // " (34)
    0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x12,0x24,0xFF,0x24,0x24,0xFF,0x48,0x48,0x48, // # (35)
    0x00,0x00,0x00,0x00,0x10,0x3C,0x52,0x90,0x90,0x70,0x1C,0x12,0x12,0x94,0x78,0x10, // $ (36)
    0x00,0x00,0x00,0x00,0x00,0x00,0xC2,0x24,0x24,0x28,0xC8,0x13,0x14,0x24,0x24,0x43, // % (37)
    0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x44,0x44,0x48,0x30,0x50,0x8A,0x84,0x86,0x79, // & (38)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00, // ' (39)
    0x00,0x00,0x00,0x00,0x08,0x10,0x10,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x10, // ( (40)
    0x00,0x00,0x00,0x00,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10, // ) (41)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x7C,0x10,0x28,0x00,0x00,0x00,0x00,0x00,0x00, // * (42)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x7F,0x08,0x08,0x08, // + (43)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // , (44)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78, // - (45)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // . (46)
    0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x08,0x08,0x08,0x10,0x10,0x10,0x20,0x20, // / (47)
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C, // 0 (48)
    0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x18,0x28,0x08,0x08,0x08,0x08,0x08,0x08,0x08, // 1 (49)
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x02,0x04,0x08,0x10,0x20,0x7E, // 2 (50)
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x1C,0x02,0x02,0x42,0x42,0x3C, // 3 (51)
    0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x0C,0x14,0x24,0x24,0x44,0x84,0xFE,0x04,0x04, // 4 (52)
    0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x20,0x40,0x7C,0x42,0x02,0x02,0x42,0x44,0x3C, // 5 (53)
    0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x22,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x3C, // 6 (54)
    0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x10,0x10, // 7 (55)
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x3C,0x42,0x42,0x42,0x42,0x3C, // 8 (56)
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x46,0x3A,0x02,0x02,0x44,0x38, // 9 (57)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00, // : (58)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x10, // ; (59)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x0C,0x30,0x40,0x30,0x0C,0x02, // < (60)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00, // = (61)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x30,0x0C,0x02,0x0C,0x30,0x40, // > (62)
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x04,0x08,0x10,0x10,0x00,0x10, // ? (63)
    0x00,0x00,0x00,0x00,0x7E,0x81,0x00,0x3A,0x46,0x82,0x84,0x84,0x8C,0x77,0x00,0x81, // @ (64)
    0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xA0,0xA0,0xA0,0x10,0x10,0xF8,0x08,0x04,0x04, // A (65)
    0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x82,0x82,0x82,0xFC,0x82,0x82,0x82,0x82,0xFC, // B (66)
    0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x81,0x80,0x80,0x80,0x80,0x81,0x42,0x3C, // C (67)
    0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x82,0x81,0x81,0x81,0x81,0x81,0x81,0x82,0xFC, // D (68)
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x80,0x80,0x80,0xFE,0x80,0x80,0x80,0x80,0xFE, // E (69)
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x80,0x80,0x80,0xFC,0x80,0x80,0x80,0x80,0x80, // F (70)
    0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x82,0x01,0x00,0x00,0x0F,0x01,0x01,0x82,0x7C, // G (71)
    0x00,0x00,0x00,0x00,0x00,0x00,0x82,0x82,0x82,0x82,0xFE,0x82,0x82,0x82,0x82,0x82, // H (72)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // I (73)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xE0, // J (74)
    0x00,0x00,0x00,0x00,0x00,0x00,0x81,0x82,0x84,0x88,0x90,0xA8,0xC4,0x84,0x82,0x81, // K (75)
    0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7F, // L (76)
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x83,0x83,0x45,0x45,0x29,0x29,0x29,0x11,0x11, // M (77)
    0x00,0x00,0x00,0x00,0x00,0x00,0x82,0xC2,0xA2,0xA2,0x92,0x92,0x8A,0x8A,0x86,0x82, // N (78)
    0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x82,0x01,0x01,0x01,0x01,0x01,0x01,0x82,0x7C, // O (79)
    0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x82,0x82,0x82,0x82,0xFC,0x80,0x80,0x80,0x80, // P (80)
    0x00,0x00,0x00,0x00,0x00,0x7C,0x82,0x01,0x01,0x01,0x01,0x01,0x0A,0x86,0x7B,0x00, // Q (81)
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x81,0x81,0x81,0x81,0xFE,0x88,0x84,0x82,0x81, // R (82)
    0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x82,0x82,0x80,0x70,0x0E,0x02,0x82,0x82,0x7C, // S (83)
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // T (84)
    0x00,0x00,0x00,0x00,0x00,0x00,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x44,0x38, // U (85)
    0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x08,0x08,0x10,0x10,0xA0,0xA0,0x40,0x40, // V (86)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x28,0x28,0x28,0x28,0x45,0x45,0x45,0x82,0x82, // W (87)
    0x00,0x00,0x00,0x00,0x00,0x00,0x81,0x42,0x42,0x24,0x18,0x18,0x24,0x42,0x42,0x81, // X (88)
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x82,0x44,0x44,0x28,0x10,0x10,0x10,0x10,0x10, // Y (89)
    0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x02,0x04,0x04,0x08,0x10,0x20,0x20,0x40,0xFF, // Z (90)
    0x00,0x00,0x00,0x00,0x18,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // [ (91)
    0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x10,0x10,0x10,0x08,0x08,0x08,0x04,0x04, // \ (92)
    0x00,0x00,0x00,0x00,0x18,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08, // ] (93)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x28,0x28,0x28,0x44,0x00,0x00,0x00,0x00,0x00, // ^ (94)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // _ (95)
    0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ` (96)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x02,0x1E,0x22,0x42,0x46, // a (97)
    0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0x62,0x5C, // b (98)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x44,0x40,0x40,0x40,0x40,0x44, // c (99)
    0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x3A,0x46,0x42,0x42,0x42,0x42,0x46,0x3A, // d (100)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x7E,0x40,0x40,0x42, // e (101)
    0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x10,0x3C,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // f (102)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3A,0x46,0x42,0x42,0x42,0x42,0x46,0x3A,0x02, // g (103)
    0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0x42,0x42, // h (104)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // i (105)
    0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // j (106)
    0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x42,0x44,0x48,0x50,0x68,0x44,0x44,0x42, // k (107)
    0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // l (108)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0x99,0x11,0x11,0x11,0x11,0x11, // m (109)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x62,0x42,0x42,0x42,0x42,0x42, // n (110)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x42, // o (111)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5C,0x62,0x42,0x42,0x42,0x42,0x62,0x5C,0x40, // p (112)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3A,0x46,0x42,0x42,0x42,0x42,0x46,0x3A,0x02, // q (113)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2C,0x30,0x20,0x20,0x20,0x20,0x20, // r (114)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x44,0x40,0x38,0x04,0x04,0x44, // s (115)
    0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x3C,0x10,0x10,0x10,0x10,0x10,0x10,0x1C,0x00, // t (116)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x46, // u (117)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x10,0x10,0xA0,0xA0,0x40, // v (118)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x11,0xAA,0xAA,0xAA,0xAA,0x44, // w (119)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x24,0x24,0x18,0x18,0x24,0x24, // x (120)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x10,0x10,0xA0,0xA0,0xA0,0x40,0x40, // y (121)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x04,0x08,0x08,0x10,0x10,0x20, // z (122)
    0x00,0x00,0x00,0x00,0x08,0x10,0x10,0x10,0x10,0x10,0x20,0x10,0x10,0x10,0x10,0x10, // { (123)
    0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // | (124)
    0x00,0x00,0x00,0x00,0x20,0x10,0x10,0x10,0x10,0x10,0x08,0x10,0x10,0x10,0x10,0x10, // } (125)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x72,0x9E,0x00,0x00, // ~ (126)
};

// UC8179 Commands (common 800x480 controller)
#define CMD_PANEL_SETTING           0x00
#define CMD_POWER_SETTING           0x01
#define CMD_POWER_OFF               0x02
#define CMD_POWER_ON                0x04
#define CMD_BOOSTER_SOFT_START      0x06
#define CMD_DEEP_SLEEP              0x07
#define CMD_DATA_START_TRANS_1      0x10
#define CMD_DATA_STOP               0x11
#define CMD_DISPLAY_REFRESH         0x12
#define CMD_DATA_START_TRANS_2      0x13
#define CMD_VCOM_LUT                0x20
#define CMD_W2W_LUT                 0x21
#define CMD_B2W_LUT                 0x22
#define CMD_W2B_LUT                 0x23
#define CMD_B2B_LUT                 0x24
#define CMD_PLL_CONTROL             0x30
#define CMD_TEMP_SENSOR_CMD         0x40
#define CMD_TEMP_SENSOR_SEL         0x41
#define CMD_VCOM_AND_DATA           0x50
#define CMD_TCON_SETTING            0x60
#define CMD_RESOLUTION_SETTING      0x61
#define CMD_GATE_SOURCE_START       0x65
#define CMD_GET_STATUS              0x71
#define CMD_AUTO_MEASURE_VCOM       0x80
#define CMD_VCOM_VALUE              0x81
#define CMD_VCM_DC_SETTING          0x82
#define CMD_PARTIAL_WINDOW          0x90
#define CMD_PARTIAL_IN              0x91
#define CMD_PARTIAL_OUT             0x92
#define CMD_FLASH_MODE              0xE5

// Helper macros
#define EPD_CS_LOW()    gpio_set_level(PIN_EPAPER_CS, 0)
#define EPD_CS_HIGH()   gpio_set_level(PIN_EPAPER_CS, 1)
#define EPD_DC_CMD()    gpio_set_level(PIN_EPAPER_DC, 0)
#define EPD_DC_DATA()   gpio_set_level(PIN_EPAPER_DC, 1)
#define EPD_RST_LOW()   gpio_set_level(PIN_EPAPER_RST, 0)
#define EPD_RST_HIGH()  gpio_set_level(PIN_EPAPER_RST, 1)
// BUSY pin is LOW when busy, HIGH when ready (inverted logic)
#define EPD_BUSY()      (gpio_get_level(PIN_EPAPER_BUSY) == 0)

static void epd_spi_write(const uint8_t *data, size_t len) {
    if (len == 0) return;
    
    spi_transaction_t t = {
        .length = len * 8,
        .tx_buffer = data,
    };
    spi_device_polling_transmit(s_spi, &t);
}

static void epd_write_cmd(uint8_t cmd) {
    EPD_DC_CMD();
    EPD_CS_LOW();
    epd_spi_write(&cmd, 1);
    EPD_CS_HIGH();
}

static void epd_write_data(const uint8_t *data, size_t len) {
    EPD_DC_DATA();
    EPD_CS_LOW();
    epd_spi_write(data, len);
    EPD_CS_HIGH();
}

static void epd_write_data_byte(uint8_t data) {
    epd_write_data(&data, 1);
}

esp_err_t epd_wait_busy(uint32_t timeout_ms) {
    uint32_t start = xTaskGetTickCount();
    while (EPD_BUSY()) {
        if ((xTaskGetTickCount() - start) * portTICK_PERIOD_MS > timeout_ms) {
            ESP_LOGW(TAG, "Busy timeout");
            return ESP_ERR_TIMEOUT;
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
    return ESP_OK;
}

bool epd_is_busy(void) {
    return EPD_BUSY() != 0;
}

static void epd_reset(void) {
    EPD_RST_HIGH();
    vTaskDelay(pdMS_TO_TICKS(20));
    EPD_RST_LOW();
    vTaskDelay(pdMS_TO_TICKS(20)); // Increased from 2ms
    EPD_RST_HIGH();
    vTaskDelay(pdMS_TO_TICKS(20));
}

static void epd_init_panel(void) {
    epd_reset();
    vTaskDelay(pdMS_TO_TICKS(100));  // Wait after reset
    epd_wait_busy(1000);
    
    // Booster soft start - critical for power stabilization
    epd_write_cmd(CMD_BOOSTER_SOFT_START);
    epd_write_data_byte(0x17);
    epd_write_data_byte(0x17);
    epd_write_data_byte(0x27);
    epd_write_data_byte(0x17);
    
    // Power setting
    epd_write_cmd(CMD_POWER_SETTING);
    epd_write_data_byte(0x07);  // VDS_EN, VDG_EN internal
    epd_write_data_byte(0x07);  // VCOM_HV, VGHL_LV=VGH=20V, VGL=-20V
    epd_write_data_byte(0x3F);  // VDH=15V
    epd_write_data_byte(0x3F);  // VDL=-15V
    
    // Power on
    epd_write_cmd(CMD_POWER_ON);
    vTaskDelay(pdMS_TO_TICKS(100));
    epd_wait_busy(5000);
    
    // Panel setting - KW mode (black/white), LUT from OTP
    epd_write_cmd(CMD_PANEL_SETTING);
    epd_write_data_byte(0x1F);  // KW-3f, KWR-2F, BWROTP 0f, BWOTP 1f
    
    // PLL Control
    epd_write_cmd(CMD_PLL_CONTROL);
    epd_write_data_byte(0x3C);  // 50Hz
    
    // Resolution setting
    epd_write_cmd(CMD_RESOLUTION_SETTING);
    epd_write_data_byte((EPD_WIDTH >> 8) & 0xFF);
    epd_write_data_byte(EPD_WIDTH & 0xFF);
    epd_write_data_byte((EPD_HEIGHT >> 8) & 0xFF);
    epd_write_data_byte(EPD_HEIGHT & 0xFF);
    
    // TCON setting - non-overlap period
    epd_write_cmd(CMD_TCON_SETTING);
    epd_write_data_byte(0x22);
    
    // VCM DC Setting
    epd_write_cmd(CMD_VCM_DC_SETTING);
    epd_write_data_byte(0x12);
    
    // VCOM and data interval setting
    epd_write_cmd(CMD_VCOM_AND_DATA);
    epd_write_data_byte(0x10);  // Border waveform
    epd_write_data_byte(0x07);  // Data polarity
    
    ESP_LOGI(TAG, "Panel initialized");
}

esp_err_t epd_init(void) {
    if (s_initialized) {
        return ESP_OK;
    }
    
    // Configure GPIO
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << PIN_EPAPER_CS) | (1ULL << PIN_EPAPER_DC) | (1ULL << PIN_EPAPER_RST),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
    };
    gpio_config(&io_conf);
    
    io_conf.pin_bit_mask = (1ULL << PIN_EPAPER_BUSY);
    io_conf.mode = GPIO_MODE_INPUT;
    gpio_config(&io_conf);
    
    EPD_CS_HIGH();
    EPD_RST_HIGH();
    
    // Initialize SPI
    spi_bus_config_t buscfg = {
        .miso_io_num = PIN_SPI_MISO,
        .mosi_io_num = PIN_SPI_MOSI,
        .sclk_io_num = PIN_SPI_CLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = SPI_MAX_TRANSFER_SIZE,
    };
    
    esp_err_t ret = spi_bus_initialize(SPI_HOST_USED, &buscfg, SPI_DMA_CHAN);
    if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
        ESP_LOGE(TAG, "SPI bus init failed: %s", esp_err_to_name(ret));
        return ret;
    }
    
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 10 * 1000 * 1000,  // 10 MHz
        .mode = 0,
        .spics_io_num = -1,  // Manual CS
        .queue_size = 1,
    };
    
    ret = spi_bus_add_device(SPI_HOST_USED, &devcfg, &s_spi);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "SPI device add failed: %s", esp_err_to_name(ret));
        return ret;
    }
    
    // Allocate framebuffer in PSRAM if available
    s_framebuffer = heap_caps_malloc(EPAPER_BUFFER_SIZE, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (!s_framebuffer) {
        s_framebuffer = heap_caps_malloc(EPAPER_BUFFER_SIZE, MALLOC_CAP_8BIT);
    }
    if (!s_framebuffer) {
        ESP_LOGE(TAG, "Framebuffer alloc failed");
        return ESP_ERR_NO_MEM;
    }
    
    memset(s_framebuffer, 0xFF, EPAPER_BUFFER_SIZE);  // White
    
    // Initialize panel
    epd_init_panel();
    
    s_initialized = true;
    ESP_LOGI(TAG, "Initialized (%dx%d)", EPD_WIDTH, EPD_HEIGHT);
    
    return ESP_OK;
}

void epd_deinit(void) {
    if (!s_initialized) return;
    
    epd_sleep();
    
    if (s_framebuffer) {
        heap_caps_free(s_framebuffer);
        s_framebuffer = NULL;
    }
    
    if (s_spi) {
        spi_bus_remove_device(s_spi);
        s_spi = NULL;
    }
    
    s_initialized = false;
}

void epd_clear(void) {
    if (!s_initialized) return;
    
    memset(s_framebuffer, 0xFF, EPAPER_BUFFER_SIZE);
    epd_display(s_framebuffer, EPD_UPDATE_FULL);
}

void epd_clear_black(void) {
    if (!s_initialized) return;
    
    memset(s_framebuffer, 0x00, EPAPER_BUFFER_SIZE);
    epd_display(s_framebuffer, EPD_UPDATE_FULL);
}

void epd_set_rotation(epd_rotation_t rotation) {
    s_rotation = rotation;
}

void epd_display(const uint8_t *buffer, epd_update_mode_t mode) {
    if (!s_initialized || !buffer) return;
    
    epd_wait_busy(10000);
    
    // Send old data (0xFF = White) to clear ghosting/ensure transition
    // NOTE: On this panel, 0x00 is White, 0xFF is Black.
    // We assume the previous frame was cleared/white (0xFF in buffer), so we send 0x00.
    epd_write_cmd(CMD_DATA_START_TRANS_1);
    
    EPD_DC_DATA();
    EPD_CS_LOW();
    
    // Create a buffer for "old data" (0x00 = White)
    uint8_t *old_buf = heap_caps_malloc(4096, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
    if (old_buf) {
        memset(old_buf, 0x00, 4096);
        for (int i = 0; i < EPAPER_BUFFER_SIZE; i += 4096) {
            size_t chunk = (EPAPER_BUFFER_SIZE - i > 4096) ? 4096 : (EPAPER_BUFFER_SIZE - i);
            epd_spi_write(old_buf, chunk);
        }
        free(old_buf);
    } else {
        // Fallback
        uint8_t val = 0x00;
        for (int i = 0; i < EPAPER_BUFFER_SIZE; i++) {
            epd_spi_write(&val, 1);
        }
    }
    EPD_CS_HIGH();
    
    // Send new data (Inverted: Buffer 1=White -> Panel 0=White)
    epd_write_cmd(CMD_DATA_START_TRANS_2);
    
    EPD_DC_DATA();
    EPD_CS_LOW();
    
    uint8_t *temp_buf = heap_caps_malloc(4096, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
    if (temp_buf) {
        for (int i = 0; i < EPAPER_BUFFER_SIZE; i += 4096) {
            size_t chunk = (EPAPER_BUFFER_SIZE - i > 4096) ? 4096 : (EPAPER_BUFFER_SIZE - i);
            
            // Copy and invert
            for (int j = 0; j < chunk; j++) {
                temp_buf[j] = ~buffer[i + j];
            }
            
            epd_spi_write(temp_buf, chunk);
        }
        free(temp_buf);
    } else {
        // Fallback
        for (int i = 0; i < EPAPER_BUFFER_SIZE; i++) {
            uint8_t val = ~buffer[i];
            epd_spi_write(&val, 1);
        }
    }
    EPD_CS_HIGH();
    
    // Refresh
    epd_write_cmd(CMD_DISPLAY_REFRESH);
    vTaskDelay(pdMS_TO_TICKS(100));
    epd_wait_busy(30000);  // Full refresh can take a while
    
    ESP_LOGI(TAG, "Display updated");
}

void epd_display_grayscale(const uint8_t *buffer) {
    // 4-level grayscale implementation would go here
    // For now, just convert to 1-bit and display
    epd_display(buffer, EPD_UPDATE_FULL);
}

void epd_display_partial(const uint8_t *buffer, int x, int y, int w, int h) {
    if (!s_initialized || !buffer) return;
    
    // Align to byte boundary
    x = (x / 8) * 8;
    w = ((w + 7) / 8) * 8;
    
    epd_wait_busy(10000);
    
    // Set partial window
    epd_write_cmd(CMD_PARTIAL_IN);
    epd_write_cmd(CMD_PARTIAL_WINDOW);
    epd_write_data_byte(x >> 8);
    epd_write_data_byte(x & 0xFF);
    epd_write_data_byte((x + w - 1) >> 8);
    epd_write_data_byte((x + w - 1) & 0xFF);
    epd_write_data_byte(y >> 8);
    epd_write_data_byte(y & 0xFF);
    epd_write_data_byte((y + h - 1) >> 8);
    epd_write_data_byte((y + h - 1) & 0xFF);
    epd_write_data_byte(0x01);
    
    // Send data
    epd_write_cmd(CMD_DATA_START_TRANS_2);
    size_t size = (w / 8) * h;
    
    uint8_t *temp_buf = heap_caps_malloc(size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
    if (temp_buf) {
        for (size_t i = 0; i < size; i++) {
            temp_buf[i] = ~buffer[i];
        }
        epd_write_data(temp_buf, size);
        free(temp_buf);
    } else {
        for (size_t i = 0; i < size; i++) {
            epd_write_data_byte(~buffer[i]);
        }
    }
    
    // Refresh partial
    epd_write_cmd(CMD_DISPLAY_REFRESH);
    vTaskDelay(pdMS_TO_TICKS(50));
    epd_wait_busy(10000);
    
    epd_write_cmd(CMD_PARTIAL_OUT);
}

void epd_sleep(void) {
    if (!s_initialized) return;
    
    epd_wait_busy(1000);
    epd_write_cmd(CMD_POWER_OFF);
    epd_wait_busy(1000);
    epd_write_cmd(CMD_DEEP_SLEEP);
    epd_write_data_byte(0xA5);
    
    ESP_LOGI(TAG, "Entered sleep");
}

void epd_wake(void) {
    if (!s_initialized) return;
    
    epd_reset();
    epd_init_panel();
    
    ESP_LOGI(TAG, "Woke from sleep");
}

uint8_t *epd_get_framebuffer(void) {
    return s_framebuffer;
}

void epd_set_pixel(int x, int y, uint8_t color) {
    if (!s_framebuffer) return;
    
    // Apply rotation
    int tx, ty;
    switch (s_rotation) {
        case EPD_ROTATE_90:
            tx = EPD_WIDTH - 1 - y;
            ty = x;
            break;
        case EPD_ROTATE_180:
            tx = EPD_WIDTH - 1 - x;
            ty = EPD_HEIGHT - 1 - y;
            break;
        case EPD_ROTATE_270:
            tx = y;
            ty = EPD_HEIGHT - 1 - x;
            break;
        default:
            tx = x;
            ty = y;
    }
    
    if (tx < 0 || tx >= EPD_WIDTH || ty < 0 || ty >= EPD_HEIGHT) return;
    
    int byte_idx = (ty * EPD_WIDTH + tx) / 8;
    int bit_idx = 7 - (tx % 8);
    
    if (color) {
        s_framebuffer[byte_idx] |= (1 << bit_idx);  // White
    } else {
        s_framebuffer[byte_idx] &= ~(1 << bit_idx); // Black
    }
}

void epd_draw_hline(int x, int y, int w, uint8_t color) {
    for (int i = 0; i < w; i++) {
        epd_set_pixel(x + i, y, color);
    }
}

void epd_draw_vline(int x, int y, int h, uint8_t color) {
    for (int i = 0; i < h; i++) {
        epd_set_pixel(x, y + i, color);
    }
}

void epd_draw_rect(int x, int y, int w, int h, uint8_t color) {
    epd_draw_hline(x, y, w, color);
    epd_draw_hline(x, y + h - 1, w, color);
    epd_draw_vline(x, y, h, color);
    epd_draw_vline(x + w - 1, y, h, color);
}

void epd_fill_rect(int x, int y, int w, int h, uint8_t color) {
    for (int j = 0; j < h; j++) {
        epd_draw_hline(x, y + j, w, color);
    }
}

void epd_draw_text(int x, int y, const char *text, int size, uint8_t color) {
    if (!text) return;
    
    int cursor_x = x;
    
    while (*text) {
        char c = *text++;
        
        // Only handle printable ASCII
        if (c < ' ' || c > '~') {
            cursor_x += 8 * size;
            continue;
        }
        
        int font_idx = (c - ' ') * 16;
        
        for (int row = 0; row < 16; row++) {
            uint8_t line = font_8x16[font_idx + row];
            
            for (int col = 0; col < 8; col++) {
                if (line & (0x80 >> col)) {
                    for (int sy = 0; sy < size; sy++) {
                        for (int sx = 0; sx < size; sx++) {
                            epd_set_pixel(cursor_x + col * size + sx, 
                                         y + row * size + sy, 
                                         color);
                        }
                    }
                }
            }
        }
        
        cursor_x += 8 * size;
    }
}

void epd_draw_text_large(int x, int y, const char *text, int size, uint8_t color) {
    if (!text) return;
    
    int cursor_x = x;
    
    while (*text) {
        uint8_t c = (uint8_t)*text++;
        int font_idx = -1;

        if (c >= ' ' && c <= '~') {
            // ASCII
            font_idx = c - ' ';
        } else if (c == 0xD7) {
            // Hebrew (possibly)
            if (*text) {
                uint8_t c2 = (uint8_t)*text++;
                uint16_t unicode = ((c & 0x1F) << 6) | (c2 & 0x3F);
                if (unicode >= 0x05D0 && unicode <= 0x05EA) {
                    font_idx = 95 + (unicode - 0x05D0);
                }
            }
        }
        
        if (font_idx >= 0) {
            for (int row = 0; row < 24; row++) {
                uint16_t line = font_16x24[font_idx * 24 + row];
                
                for (int col = 0; col < 16; col++) {
                    if (line & (0x8000 >> col)) {
                        for (int sy = 0; sy < size; sy++) {
                            for (int sx = 0; sx < size; sx++) {
                                epd_set_pixel(cursor_x + col * size + sx, 
                                             y + row * size + sy, 
                                             color);
                            }
                        }
                    }
                }
            }
        }
        
        cursor_x += 16 * size;
    }
}

int epd_get_text_width(const char *text, int size) {
    if (!text) return 0;
    return strlen(text) * 8 * size;
}

int epd_get_text_width_large(const char *text, int size) {
    if (!text) return 0;
    int len = 0;
    const char *p = text;
    while (*p) {
        uint8_t c = (uint8_t)*p++;
        if (c >= ' ' && c <= '~') {
            len++;
        } else if (c == 0xD7) {
            if (*p) {
                p++;
                len++;
            }
        }
    }
    return len * 16 * size;
}
